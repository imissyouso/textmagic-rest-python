# coding: utf-8

"""
    TextMagic API Documentation

    # Overview ## Introduction test <img style=\"float: right; margin-left: 10px; width: 100px;\" src=\"images/phone.png\"> TextMagic SMS API is a platform for building your own messaging app using our messaging infrastructure. It allows you to send and receive SMS text messages, query information about inbound and outbound messages, manage contacts, create templates (i.e. message formats and static texts) and schedule recurrent SMS messages as well as process bulk SMS messages. <button name=\"button\" onclick=\"http://www.google.com\" class=\"btn\">Try TextMagic API for Free</button>  ### Two Ways to Use TextMagic API * [REST API](https://www.textmagic.com/docs/api/start/) – get full access to TextMagic’s messaging gateway features * [Email to SMS API](https://www.textmagic.com/docs/api/send-email-to-sms/) – set up two-way SMS communication without the need to write any additional code  ### Code Libraries We have created a set of client libraries for the most popular programming languages (such as REST API Java and REST API PHP). These libraries allow you to integrate our API into your code in minutes. Just choose your preferred language to get started:  ## Getting started Get Started with the TextMagic REST API To start sending text messages using the TextMagic REST API, just follow these steps: 1. Generate the API credentials 1. Connect to our API endpoint This page provides all the information you need to get started. Here, we explain the following steps:  How to obtain the API credentials The API endpoint How the REST API works The next step How to obtain the API credentials  ### How to obtain the API credentials To start sending text messages, you need to create an API key. API keys are similar to an account password; the difference is that an API key only provides access to the API: you cannot log in to TextMagic Online using the API key.  Your program sends the login credentials with each API request as HTTP headers: `X-TM-Username` is your TextMagic username, while `X-TM-Key` is your API key.  How to obtain an API key:  1. Log in to TextMagic (or start a free trial if you haven’t registered yet). 1. Go to the API settings page. 1. Click the Add new API key button. 1. Enter an app name for this key. Note, it’s just a label, so pick any name. 1. Click Generate new key. 1. You should now see your new API key in the green notification banner above the table:  ![alt text](images/credentials.png)  > Note for API v1 users > V1 keys are not compatible with the V2 version of the TextMagic REST API, so you will need to generate a new API key to use the V2 endpoint.  ### The API endpoint The TextMagic REST API endpoint is: ``` https://rest.textmagic.com/api/v2 ``` All the URLs referenced in this documentation should use this base URL.  ### How the REST API works REST APIs use the HTTP protocol to send and receive messages. REST messages are usually encoded as JSON documents and are an improvement over older methods such as the XML based SOAP protocol. REST APIs use the same set of methods that web browsers use: POST, GET, PUT or DELETE. These correspond to the CRUD operations: create, read, update and delete. Often, REST URIs provide direct CRUD access to entities or collections of entities, for example: http://api.foo.com/people. In this instance, to delete a person’s endpoint, you might simply call the endpoint DELETE http://api.foo.com/people/{id}. REST makes these types of operations simple.  > Example > > Let’s take the entity most often used in messaging: contacts. Imagine you want to perform operations on your contacts list: well, it’s only a matter of calling the following endpoints: > * GET /api/v2/contacts (get all of your contacts) > * GET /api/v2/contacts/{id} (get a specific contact) > * POST /api/v2/contacts (create a new contact) > * PUT /api/v2/contacts/{id} (update an existing contact) > * DELETE /api/v2/contacts/{id} (delete an existing contact) It’s that simple! In fact, that’s all you need to do to manage the contacts in your TextMagic account!  ## Sandbox Sandbox is a tool to test TextMagic REST API requests without the need to install any applications or write any code. Here, we explain the following details about Sandbox: * The credentials area * Command documentation * How it works  <a href=\"\">Go to TextMagic Sandbox</a>  ### The credentials area To make requests using your TextMagic account, you need to enter your account username and your API key into the corresponding fields. You may also Save them in your browser or press Clear to erase them.  ![alt text](images/sandbox.png)   # noqa: E501

    OpenAPI spec version: 2
    Contact: support@textmagi.biz
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from TextMagic.api_client import ApiClient


class OutboundMessagesApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def delete_all_outbound_messages(self, **kwargs):  # noqa: E501
        """Delete all messages  # noqa: E501

        Delete all messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_all_outbound_messages(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_all_outbound_messages_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delete_all_outbound_messages_with_http_info(**kwargs)  # noqa: E501
            return data

    def delete_all_outbound_messages_with_http_info(self, **kwargs):  # noqa: E501
        """Delete all messages  # noqa: E501

        Delete all messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_all_outbound_messages_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_all_outbound_messages" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/message/all', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_outbound_message(self, id, **kwargs):  # noqa: E501
        """Delete message  # noqa: E501

        Delete a single message.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_outbound_message(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_outbound_message_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_outbound_message_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_outbound_message_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete message  # noqa: E501

        Delete a single message.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_outbound_message_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_outbound_message" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_outbound_message`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/messages/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_outbound_messages_bulk(self, delete_outbound_messages_bulk_input_object, **kwargs):  # noqa: E501
        """Delete messages by IDs  # noqa: E501

        Delete outbound messages by given ID(s) or delete all outbound messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_outbound_messages_bulk(delete_outbound_messages_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteOutboundMessagesBulkInputObject delete_outbound_messages_bulk_input_object: (required)
        :param bool x_ignore_null_values:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_outbound_messages_bulk_with_http_info(delete_outbound_messages_bulk_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_outbound_messages_bulk_with_http_info(delete_outbound_messages_bulk_input_object, **kwargs)  # noqa: E501
            return data

    def delete_outbound_messages_bulk_with_http_info(self, delete_outbound_messages_bulk_input_object, **kwargs):  # noqa: E501
        """Delete messages by IDs  # noqa: E501

        Delete outbound messages by given ID(s) or delete all outbound messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_outbound_messages_bulk_with_http_info(delete_outbound_messages_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteOutboundMessagesBulkInputObject delete_outbound_messages_bulk_input_object: (required)
        :param bool x_ignore_null_values:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['delete_outbound_messages_bulk_input_object', 'x_ignore_null_values']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_outbound_messages_bulk" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'delete_outbound_messages_bulk_input_object' is set
        if ('delete_outbound_messages_bulk_input_object' not in params or
                params['delete_outbound_messages_bulk_input_object'] is None):
            raise ValueError("Missing the required parameter `delete_outbound_messages_bulk_input_object` when calling `delete_outbound_messages_bulk`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'x_ignore_null_values' in params:
            header_params['X-Ignore-Null-Values'] = params['x_ignore_null_values']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'delete_outbound_messages_bulk_input_object' in params:
            body_params = params['delete_outbound_messages_bulk_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/messages/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_outbound_messages(self, **kwargs):  # noqa: E501
        """Get all messages  # noqa: E501

        Get all user oubound messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_outbound_messages(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page
        :param int limit: How many results to return
        :param int last_id: Filter results by ID, selecting all values lesser than the specified ID. Note that \\'page\\' parameter is ignored when \\'lastId\\' is specified
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_outbound_messages_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_outbound_messages_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_outbound_messages_with_http_info(self, **kwargs):  # noqa: E501
        """Get all messages  # noqa: E501

        Get all user oubound messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_outbound_messages_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page
        :param int limit: How many results to return
        :param int last_id: Filter results by ID, selecting all values lesser than the specified ID. Note that \\'page\\' parameter is ignored when \\'lastId\\' is specified
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit', 'last_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_outbound_messages" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'last_id' in params:
            query_params.append(('lastId', params['last_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/messages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='dict(str, object)',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_message_preview(self, **kwargs):  # noqa: E501
        """Preview message  # noqa: E501

        Get messages preview (with tags merged) up to 100 messages per session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_message_preview(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str text: Message text. Required if template_id is not set
        :param int template_id: Template used instead of message text. Required if text is not set
        :param int sending_time: DEPRECATED, consider using sendingDateTime and sendingTimezone parameters instead: Optional (required with rrule set). Message sending time in unix timestamp format. Default is now
        :param str sending_date_time: Sending time in Y-m-d H:i:s format (e.g. 2016-05-27 13:02:33). This time is relative to sendingTimezone
        :param str sending_timezone: ID or ISO-name of timezone used for sending when sendingDateTime parameter is set. E.g. if you specify sendingDateTime = \\\"2016-05-27 13:02:33\\\" and sendingTimezone = \\\"America/Buenos_Aires\\\", your message will be sent at May 27, 2016 13:02:33 Buenos Aires time, or 16:02:33 UTC. Default is account timezone
        :param str contacts: Comma separated array of contact resources id message will be sent to
        :param str lists: Comma separated array of list resources id message will be sent to
        :param str phones: Comma separated array of E.164 phone numbers message will be sent to
        :param int cut_extra: Should sending method cut extra characters which not fit supplied partsCount or return 400 Bad request response instead. Default is 0
        :param int parts_count: Maximum message parts count (TextMagic allows sending 1 to 6 message parts). Default is 6
        :param int reference_id: Custom message reference id which can be used in your application infrastructure
        :param str _from: One of allowed Sender ID (phone number or alphanumeric sender ID). If specified Sender ID is not allowed for some destinations, a fallback default Sender ID will be used to ensure delivery
        :param str rule: iCal RRULE parameter to create recurrent scheduled messages. When used, sendingTime is mandatory as start point of sending. See https://www.textmagic.com/free-tools/rrule-generator for format details
        :param int create_chat: Should sending method try to create new Chat(if not exist) with specified recipients. Default is 0
        :param int tts: Send Text to Speech message. Default is 0
        :param int local: Treat phone numbers passed in \\'phones\\' field as local. Default is 0
        :param str local_country: 2-letter ISO country code for local phone numbers, used when \\'local\\' is set to true. Default is account country
        :return: GetMessagePreviewResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_message_preview_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_message_preview_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_message_preview_with_http_info(self, **kwargs):  # noqa: E501
        """Preview message  # noqa: E501

        Get messages preview (with tags merged) up to 100 messages per session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_message_preview_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str text: Message text. Required if template_id is not set
        :param int template_id: Template used instead of message text. Required if text is not set
        :param int sending_time: DEPRECATED, consider using sendingDateTime and sendingTimezone parameters instead: Optional (required with rrule set). Message sending time in unix timestamp format. Default is now
        :param str sending_date_time: Sending time in Y-m-d H:i:s format (e.g. 2016-05-27 13:02:33). This time is relative to sendingTimezone
        :param str sending_timezone: ID or ISO-name of timezone used for sending when sendingDateTime parameter is set. E.g. if you specify sendingDateTime = \\\"2016-05-27 13:02:33\\\" and sendingTimezone = \\\"America/Buenos_Aires\\\", your message will be sent at May 27, 2016 13:02:33 Buenos Aires time, or 16:02:33 UTC. Default is account timezone
        :param str contacts: Comma separated array of contact resources id message will be sent to
        :param str lists: Comma separated array of list resources id message will be sent to
        :param str phones: Comma separated array of E.164 phone numbers message will be sent to
        :param int cut_extra: Should sending method cut extra characters which not fit supplied partsCount or return 400 Bad request response instead. Default is 0
        :param int parts_count: Maximum message parts count (TextMagic allows sending 1 to 6 message parts). Default is 6
        :param int reference_id: Custom message reference id which can be used in your application infrastructure
        :param str _from: One of allowed Sender ID (phone number or alphanumeric sender ID). If specified Sender ID is not allowed for some destinations, a fallback default Sender ID will be used to ensure delivery
        :param str rule: iCal RRULE parameter to create recurrent scheduled messages. When used, sendingTime is mandatory as start point of sending. See https://www.textmagic.com/free-tools/rrule-generator for format details
        :param int create_chat: Should sending method try to create new Chat(if not exist) with specified recipients. Default is 0
        :param int tts: Send Text to Speech message. Default is 0
        :param int local: Treat phone numbers passed in \\'phones\\' field as local. Default is 0
        :param str local_country: 2-letter ISO country code for local phone numbers, used when \\'local\\' is set to true. Default is account country
        :return: GetMessagePreviewResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['text', 'template_id', 'sending_time', 'sending_date_time', 'sending_timezone', 'contacts', 'lists', 'phones', 'cut_extra', 'parts_count', 'reference_id', '_from', 'rule', 'create_chat', 'tts', 'local', 'local_country']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_message_preview" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'text' in params:
            query_params.append(('text', params['text']))  # noqa: E501
        if 'template_id' in params:
            query_params.append(('templateId', params['template_id']))  # noqa: E501
        if 'sending_time' in params:
            query_params.append(('sendingTime', params['sending_time']))  # noqa: E501
        if 'sending_date_time' in params:
            query_params.append(('sendingDateTime', params['sending_date_time']))  # noqa: E501
        if 'sending_timezone' in params:
            query_params.append(('sendingTimezone', params['sending_timezone']))  # noqa: E501
        if 'contacts' in params:
            query_params.append(('contacts', params['contacts']))  # noqa: E501
        if 'lists' in params:
            query_params.append(('lists', params['lists']))  # noqa: E501
        if 'phones' in params:
            query_params.append(('phones', params['phones']))  # noqa: E501
        if 'cut_extra' in params:
            query_params.append(('cutExtra', params['cut_extra']))  # noqa: E501
        if 'parts_count' in params:
            query_params.append(('partsCount', params['parts_count']))  # noqa: E501
        if 'reference_id' in params:
            query_params.append(('referenceId', params['reference_id']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'rule' in params:
            query_params.append(('rule', params['rule']))  # noqa: E501
        if 'create_chat' in params:
            query_params.append(('createChat', params['create_chat']))  # noqa: E501
        if 'tts' in params:
            query_params.append(('tts', params['tts']))  # noqa: E501
        if 'local' in params:
            query_params.append(('local', params['local']))  # noqa: E501
        if 'local_country' in params:
            query_params.append(('localCountry', params['local_country']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/messages/preview', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetMessagePreviewResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_message_price(self, **kwargs):  # noqa: E501
        """Check price  # noqa: E501

        Check pricing for a new outbound message.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_message_price(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int include_blocked: Should we show pricing for the blocked contacts.
        :param str text: Message text. Required if template_id is not set
        :param int template_id: Template used instead of message text. Required if text is not set
        :param int sending_time: DEPRECATED, consider using sendingDateTime and sendingTimezone parameters instead: Optional (required with rrule set). Message sending time in unix timestamp format. Default is now
        :param str sending_date_time: Sending time in Y-m-d H:i:s format (e.g. 2016-05-27 13:02:33). This time is relative to sendingTimezone
        :param str sending_timezone: ID or ISO-name of timezone used for sending when sendingDateTime parameter is set. E.g. if you specify sendingDateTime = \\\"2016-05-27 13:02:33\\\" and sendingTimezone = \\\"America/Buenos_Aires\\\", your message will be sent at May 27, 2016 13:02:33 Buenos Aires time, or 16:02:33 UTC. Default is account timezone
        :param str contacts: Comma separated array of contact resources id message will be sent to
        :param str lists: Comma separated array of list resources id message will be sent to
        :param str phones: Comma separated array of E.164 phone numbers message will be sent to
        :param int cut_extra: Should sending method cut extra characters which not fit supplied partsCount or return 400 Bad request response instead. Default is 0
        :param int parts_count: Maximum message parts count (TextMagic allows sending 1 to 6 message parts). Default is 6
        :param int reference_id: Custom message reference id which can be used in your application infrastructure
        :param str _from: One of allowed Sender ID (phone number or alphanumeric sender ID). If specified Sender ID is not allowed for some destinations, a fallback default Sender ID will be used to ensure delivery
        :param str rule: iCal RRULE parameter to create recurrent scheduled messages. When used, sendingTime is mandatory as start point of sending. See https://www.textmagic.com/free-tools/rrule-generator for format details
        :param int create_chat: Should sending method try to create new Chat(if not exist) with specified recipients. Default is 0
        :param int tts: Send Text to Speech message. Default is 0
        :param int local: Treat phone numbers passed in \\'phones\\' field as local. Default is 0
        :param str local_country: 2-letter ISO country code for local phone numbers, used when \\'local\\' is set to true. Default is account country
        :return: GetMessagePriceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_message_price_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_message_price_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_message_price_with_http_info(self, **kwargs):  # noqa: E501
        """Check price  # noqa: E501

        Check pricing for a new outbound message.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_message_price_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int include_blocked: Should we show pricing for the blocked contacts.
        :param str text: Message text. Required if template_id is not set
        :param int template_id: Template used instead of message text. Required if text is not set
        :param int sending_time: DEPRECATED, consider using sendingDateTime and sendingTimezone parameters instead: Optional (required with rrule set). Message sending time in unix timestamp format. Default is now
        :param str sending_date_time: Sending time in Y-m-d H:i:s format (e.g. 2016-05-27 13:02:33). This time is relative to sendingTimezone
        :param str sending_timezone: ID or ISO-name of timezone used for sending when sendingDateTime parameter is set. E.g. if you specify sendingDateTime = \\\"2016-05-27 13:02:33\\\" and sendingTimezone = \\\"America/Buenos_Aires\\\", your message will be sent at May 27, 2016 13:02:33 Buenos Aires time, or 16:02:33 UTC. Default is account timezone
        :param str contacts: Comma separated array of contact resources id message will be sent to
        :param str lists: Comma separated array of list resources id message will be sent to
        :param str phones: Comma separated array of E.164 phone numbers message will be sent to
        :param int cut_extra: Should sending method cut extra characters which not fit supplied partsCount or return 400 Bad request response instead. Default is 0
        :param int parts_count: Maximum message parts count (TextMagic allows sending 1 to 6 message parts). Default is 6
        :param int reference_id: Custom message reference id which can be used in your application infrastructure
        :param str _from: One of allowed Sender ID (phone number or alphanumeric sender ID). If specified Sender ID is not allowed for some destinations, a fallback default Sender ID will be used to ensure delivery
        :param str rule: iCal RRULE parameter to create recurrent scheduled messages. When used, sendingTime is mandatory as start point of sending. See https://www.textmagic.com/free-tools/rrule-generator for format details
        :param int create_chat: Should sending method try to create new Chat(if not exist) with specified recipients. Default is 0
        :param int tts: Send Text to Speech message. Default is 0
        :param int local: Treat phone numbers passed in \\'phones\\' field as local. Default is 0
        :param str local_country: 2-letter ISO country code for local phone numbers, used when \\'local\\' is set to true. Default is account country
        :return: GetMessagePriceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['include_blocked', 'text', 'template_id', 'sending_time', 'sending_date_time', 'sending_timezone', 'contacts', 'lists', 'phones', 'cut_extra', 'parts_count', 'reference_id', '_from', 'rule', 'create_chat', 'tts', 'local', 'local_country']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_message_price" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'include_blocked' in params:
            query_params.append(('includeBlocked', params['include_blocked']))  # noqa: E501
        if 'text' in params:
            query_params.append(('text', params['text']))  # noqa: E501
        if 'template_id' in params:
            query_params.append(('templateId', params['template_id']))  # noqa: E501
        if 'sending_time' in params:
            query_params.append(('sendingTime', params['sending_time']))  # noqa: E501
        if 'sending_date_time' in params:
            query_params.append(('sendingDateTime', params['sending_date_time']))  # noqa: E501
        if 'sending_timezone' in params:
            query_params.append(('sendingTimezone', params['sending_timezone']))  # noqa: E501
        if 'contacts' in params:
            query_params.append(('contacts', params['contacts']))  # noqa: E501
        if 'lists' in params:
            query_params.append(('lists', params['lists']))  # noqa: E501
        if 'phones' in params:
            query_params.append(('phones', params['phones']))  # noqa: E501
        if 'cut_extra' in params:
            query_params.append(('cutExtra', params['cut_extra']))  # noqa: E501
        if 'parts_count' in params:
            query_params.append(('partsCount', params['parts_count']))  # noqa: E501
        if 'reference_id' in params:
            query_params.append(('referenceId', params['reference_id']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'rule' in params:
            query_params.append(('rule', params['rule']))  # noqa: E501
        if 'create_chat' in params:
            query_params.append(('createChat', params['create_chat']))  # noqa: E501
        if 'tts' in params:
            query_params.append(('tts', params['tts']))  # noqa: E501
        if 'local' in params:
            query_params.append(('local', params['local']))  # noqa: E501
        if 'local_country' in params:
            query_params.append(('localCountry', params['local_country']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/messages/price', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetMessagePriceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_message_prices(self, **kwargs):  # noqa: E501
        """Get pricing  # noqa: E501

        Get message prices for all countries.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_message_prices(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetMessagePricesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_message_prices_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_message_prices_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_message_prices_with_http_info(self, **kwargs):  # noqa: E501
        """Get pricing  # noqa: E501

        Get message prices for all countries.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_message_prices_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetMessagePricesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_message_prices" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/messages/prices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetMessagePricesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_outbound_message(self, id, **kwargs):  # noqa: E501
        """Get a single message  # noqa: E501

        Get a single outgoing message.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_outbound_message(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: MessageOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_outbound_message_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_outbound_message_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_outbound_message_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a single message  # noqa: E501

        Get a single outgoing message.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_outbound_message_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: MessageOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_outbound_message" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_outbound_message`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/messages/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_outbound_messages_history(self, **kwargs):  # noqa: E501
        """Get history  # noqa: E501

        Get outbound messages history.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_outbound_messages_history(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: How many results to return
        :param int last_id: Filter results by ID, selecting all values lesser than the specified ID.
        :param str query: Find message by specified search query
        :param str order_by: Order results by some field. Default is id
        :param str direction: Order direction. Default is desc
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_outbound_messages_history_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_outbound_messages_history_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_outbound_messages_history_with_http_info(self, **kwargs):  # noqa: E501
        """Get history  # noqa: E501

        Get outbound messages history.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_outbound_messages_history_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: How many results to return
        :param int last_id: Filter results by ID, selecting all values lesser than the specified ID.
        :param str query: Find message by specified search query
        :param str order_by: Order results by some field. Default is id
        :param str direction: Order direction. Default is desc
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['limit', 'last_id', 'query', 'order_by', 'direction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_outbound_messages_history" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'last_id' in params:
            query_params.append(('lastId', params['last_id']))  # noqa: E501
        if 'query' in params:
            query_params.append(('query', params['query']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='dict(str, object)',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_outbound_messages(self, **kwargs):  # noqa: E501
        """Find messages  # noqa: E501

        Find outbound messages by given parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_outbound_messages(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page
        :param int limit: How many results to return
        :param int last_id: Filter results by ID, selecting all values lesser than the specified ID. Note that \\'page\\' parameter is ignored when \\'lastId\\' is specified
        :param str ids: Find message by ID(s)
        :param int session_id: Find messages by session ID
        :param str statuses: Find messages by status
        :param int include_deleted: Search also in deleted messages
        :param str query: Find messages by specified search query
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_outbound_messages_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_outbound_messages_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_outbound_messages_with_http_info(self, **kwargs):  # noqa: E501
        """Find messages  # noqa: E501

        Find outbound messages by given parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_outbound_messages_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page
        :param int limit: How many results to return
        :param int last_id: Filter results by ID, selecting all values lesser than the specified ID. Note that \\'page\\' parameter is ignored when \\'lastId\\' is specified
        :param str ids: Find message by ID(s)
        :param int session_id: Find messages by session ID
        :param str statuses: Find messages by status
        :param int include_deleted: Search also in deleted messages
        :param str query: Find messages by specified search query
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit', 'last_id', 'ids', 'session_id', 'statuses', 'include_deleted', 'query']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_outbound_messages" % key
                )
            params[key] = val
        del params['kwargs']

        if 'ids' in params and not re.search(r'[,\\d]+', params['ids']):  # noqa: E501
            raise ValueError("Invalid value for parameter `ids` when calling `search_outbound_messages`, must conform to the pattern `/[,\\d]+/`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'last_id' in params:
            query_params.append(('lastId', params['last_id']))  # noqa: E501
        if 'ids' in params:
            query_params.append(('ids', params['ids']))  # noqa: E501
        if 'session_id' in params:
            query_params.append(('sessionId', params['session_id']))  # noqa: E501
        if 'statuses' in params:
            query_params.append(('statuses', params['statuses']))  # noqa: E501
        if 'include_deleted' in params:
            query_params.append(('includeDeleted', params['include_deleted']))  # noqa: E501
        if 'query' in params:
            query_params.append(('query', params['query']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/messages/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='dict(str, object)',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def send_message(self, send_message_input_object, **kwargs):  # noqa: E501
        """Send message  # noqa: E501

        The main entrypoint to send messages. See examples above for the reference.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.send_message(send_message_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SendMessageInputObject send_message_input_object: (required)
        :param bool x_ignore_null_values:
        :return: SendMessageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.send_message_with_http_info(send_message_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.send_message_with_http_info(send_message_input_object, **kwargs)  # noqa: E501
            return data

    def send_message_with_http_info(self, send_message_input_object, **kwargs):  # noqa: E501
        """Send message  # noqa: E501

        The main entrypoint to send messages. See examples above for the reference.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.send_message_with_http_info(send_message_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SendMessageInputObject send_message_input_object: (required)
        :param bool x_ignore_null_values:
        :return: SendMessageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['send_message_input_object', 'x_ignore_null_values']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method send_message" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'send_message_input_object' is set
        if ('send_message_input_object' not in params or
                params['send_message_input_object'] is None):
            raise ValueError("Missing the required parameter `send_message_input_object` when calling `send_message`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'x_ignore_null_values' in params:
            header_params['X-Ignore-Null-Values'] = params['x_ignore_null_values']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'send_message_input_object' in params:
            body_params = params['send_message_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/messages', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SendMessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_message_attachment(self, file, **kwargs):  # noqa: E501
        """Upload message attachment  # noqa: E501

        Upload a new file to insert it as a link.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_message_attachment(file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file file: Attachment. Supports .jpg, .gif, .png, .pdf, .txt, .csv, .doc, .docx, .xls, .xlsx, .ppt, .pptx & .vcf file formats (required)
        :return: UploadMessageAttachmentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upload_message_attachment_with_http_info(file, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_message_attachment_with_http_info(file, **kwargs)  # noqa: E501
            return data

    def upload_message_attachment_with_http_info(self, file, **kwargs):  # noqa: E501
        """Upload message attachment  # noqa: E501

        Upload a new file to insert it as a link.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_message_attachment_with_http_info(file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file file: Attachment. Supports .jpg, .gif, .png, .pdf, .txt, .csv, .doc, .docx, .xls, .xlsx, .ppt, .pptx & .vcf file formats (required)
        :return: UploadMessageAttachmentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_message_attachment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `upload_message_attachment`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/messages/attachment', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UploadMessageAttachmentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
